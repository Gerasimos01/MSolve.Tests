<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MGroup.Solvers</name>
    </assembly>
    <members>
        <member name="T:MGroup.Solvers.Assemblers.CscMatrixAssembler">
            <summary>
            Builds the global matrix of the linear system that will be solved. This matrix is square and stored in CSC format, but
            both triangles are explicitly stored. This format is suitable for matrix/vector multiplications, therefore it can be 
            combined with many iterative solvers. 
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Assemblers.CscMatrixAssembler.#ctor(System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="sortRowsOfEachCol">
            Sorting the rows of each column in the CSC storage format may increase performance of the matrix vector 
            multiplications. It is recommended to set it to true, especially for iterative linear system solvers.
            </param>
        </member>
        <member name="T:MGroup.Solvers.Assemblers.CsrMatrixAssembler">
            <summary>
            Builds the global matrix of the linear system that will be solved. This matrix is square and stored in CSR format, but
            both triangles are explicitly stored. This format is suitable for matrix/vector multiplications, therefore it can be 
            combined with many iterative solvers. 
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Assemblers.CsrMatrixAssembler.#ctor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="sortColsOfEachRow">
            Sorting the columns of each row in the CSR storage format may increase performance of the matrix vector 
            multiplications. It is recommended to set it to true, especially for iterative linear system solvers.
            </param>
        </member>
        <member name="T:MGroup.Solvers.Assemblers.DenseMatrixAssembler">
            <summary>
            Builds the global matrix of the linear system that will be solved. This matrix is full column major format. It can be 
            symmetric, but both triangles will be stored explicitly.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.Solvers.Assemblers.ISubdomainMatrixAssembler`1">
            <summary>
            Builds the matrix of the linear system that will be solved.
            Authors: Serafeim Bakalakos
            </summary>
            <typeparam name="TMatrix">The type of the matrix that will be solved.</typeparam>
        </member>
        <member name="M:MGroup.Solvers.Assemblers.ISubdomainMatrixAssembler`1.BuildGlobalMatrix(MGroup.Solvers.DofOrdering.ISubdomainFreeDofOrdering,System.Collections.Generic.IEnumerable{MGroup.MSolve.Discretization.IElementType},MGroup.MSolve.Discretization.Providers.IElementMatrixProvider)">
            <summary>
            Builds the linear system matrix that corresponds to the free freedom degrees of a subdomain.
            </summary>
            <param name="dofOrdering">The free freedom degree ordering of the subdomain.</param>
            <param name="elements">The (finite) elements of the subdomain.</param>
            <param name="matrixProvider">Determines the matrix calculated for each element (e.g. stiffness, mass, etc.)</param>
        </member>
        <member name="M:MGroup.Solvers.Assemblers.ISubdomainMatrixAssembler`1.HandleDofOrderingWasModified">
            <summary>
            Update internal state when the freedom degree ordering is changed (e.g. reordering, XFEM, adaptive FEM). It 
            will be called after modifying the current freedom degree ordering.
            </summary>
        </member>
        <member name="T:MGroup.Solvers.Assemblers.SkylineMatrixAssembler">
            <summary>
            Builds the global matrix of the linear system that will be solved. This matrix is symmetric and stored in Skyline 
            format, which is suitable for the Cholesky factorization (e.g. in a direct solver).
            </summary>
        </member>
        <member name="T:MGroup.Solvers.Assemblers.SymmetricCscMatrixAssembler">
            <summary>
            Builds the global matrix of the linear system that will be solved. This matrix is in symmetric CSC format, namely only 
            the upper triangle is explicitly stored. This format is suitable for the SuiteSparse library and solvers that use it.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Assemblers.SymmetricCscMatrixAssembler.#ctor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="sortColsOfEachRow">
            Sorting the columns of each row in the CSC storage format may increase performance of the factorization and 
            back/forward substitutions. It is recommended to set it to true.
            </param>
        </member>
        <member name="T:MGroup.Solvers.Assemblers.SymmetricDokMatrixAssembler">
            <summary>
            Builds the global matrix of the linear system that will be solved. This matrix is in symmetric DOK format, namely only 
            the upper triangle is explicitly stored.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.Solvers.Direct.DenseMatrixSolver">
            <summary>
            Direct solver for models with only 1 subdomain. Uses Cholesky factorization on symmetric positive definite matrices
            stored in full format. Its purpose is mainly for testing, since it is inefficient for large linear systems resulting 
            from FEM .
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Direct.DenseMatrixSolver.Solve">
            <summary>
            Solves the linear system with back-forward substitution. If the matrix has been modified, it will be refactorized.
            </summary>
        </member>
        <member name="T:MGroup.Solvers.Direct.SkylineSolver">
            <summary>
            Direct solver for models with only 1 subdomain. Uses Cholesky factorization on sparse symmetric positive definite 
            matrices stored in Skyline format.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Direct.SkylineSolver.Solve">
            <summary>
            Solves the linear system with back-forward substitution. If the matrix has been modified, it will be refactorized.
            </summary>
        </member>
        <member name="T:MGroup.Solvers.Direct.SuiteSparseSolver">
            <summary>
            Direct solver for models with only 1 subdomain. Uses Cholesky factorization on sparse symmetric positive definite 
            matrices stored in symmetric (only the upper triangle) format. Uses native dlls from the SuiteSparse library. 
            The factorized matrix and other data are stored in unmanaged memory and properly disposed by this class.
            The default behaviour is to apply AMD reordering before Cholesky factorization.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Direct.SuiteSparseSolver.Solve">
            <summary>
            Solves the linear system with back-forward substitution. If the matrix has been modified, it will be refactorized.
            </summary>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.DofOrderer">
            <summary>
            Orders the unconstrained freedom degrees of a subdomain. Optionally applies reordering and other optimizations.
            </summary>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.IDofOrderer">
            <summary>
            Orders the unconstrained freedom degrees (dofs) of the physical model's subdomains, by assigning an index to each unique 
            (node, dof) pair. These indices are used in vectors and matrices that contain quantities for a whole subdomain to locate 
            the contribution of each dof.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.DofOrdering.IDofOrderer.OrderFreeDofs(MGroup.MSolve.Discretization.Entities.ISubdomain,MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModelInterpreter)">
            <summary>
            Finds an ordering for the unconstrained freedom degrees of one of the physical model's subdomains.
            </summary>
            <param name="subdomain">A subdomain consisting of a subset of the nodes and elements of the total model.</param>
            <param name="boundaryConditionsInterpreter"></param>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.IFreeDofOrderingStrategy">
            <summary>
            Determines how the unconstrained freedom degrees of the physical model will be ordered.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.DofOrdering.IFreeDofOrderingStrategy.OrderSubdomainDofs(MGroup.MSolve.Discretization.Entities.ISubdomain,MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModelInterpreter)">
            <summary>
            Orders the unconstrained freedom degrees of one of the model's subdomains.
            </summary>
            <param name="subdomain">A subdomain of the whole model.</param>
            <param name="boundaryConditionsInterpreter">A <see cref="T:MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModelInterpreter"/> for defining the constrained freedom degrees of the subdomain/>.</param>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.NodeMajorDofOrderingStrategy">
            <summary>
            Free dofs are assigned global / subdomain indices in a node major fashion: The dofs of the first node are 
            numbered, then the dofs of the second node, etc. Constrained dofs are ignored.
            </summary>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.Reordering.AmdReordering">
            <summary>
            Reorders the unconstrained freedom degrees according to the fill-reducing permutation calculated by the Approximate 
            Minimum Degree algorithm. Note that the pattern of the sparse matrix, i.e. the positions of its non-zero entries, must 
            be constructed and then passed to AMD. These might be costly operations and AMD might fail.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.Reordering.CompositeReordering">
            <summary>
            Reorders the unconstrained freedom degrees by using multiple other reordering strategies. For now, only consecutive 
            application of each reordering strategy is possible.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.Reordering.IDofReorderingStrategy">
            <summary>
            Reorders the unconstrained freedom degrees of a subdomain.
            Author: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.DofOrdering.Reordering.IDofReorderingStrategy.ReorderDofs(MGroup.MSolve.Discretization.Entities.ISubdomain,MGroup.Solvers.DofOrdering.ISubdomainFreeDofOrdering)">
            <summary>
            Reorders the unconstrained freedom degrees of a subdomain, given an existing ordering.
            </summary>
            <param name="subdomain">The subdomain whose freedom degrees will be reordered.</param>
            <param name="originalOrdering">The current ordering of the subdomain's freedom degrees. It will be modified.</param>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.Reordering.NodeMajorReordering">
            <summary>
            Reorders the unconstrained freedom degrees of a subdomain, such that they are sorted in a node major fashion: The dofs 
            of the first node are numbered, then the dofs of the second node, etc.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.Reordering.NullReordering">
            <summary>
            Does not apply any reordering. No object is mutated due to this class.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.Solvers.DofOrdering.UniformDofOrderingStrategy">
            <summary>
            Free dofs are assigned global / subdomain indices in a node major fashion: The dofs of the first node are numbered, then 
            the dofs of the second node, etc. Note that the dofs of each node are assumed to be the same and supplied by the client. 
            Based on that assumption, this class is much faster than its alternatives. Constrained dofs are ignored.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.DofSet.EnumerateOrderedNodesDofs">
            <summary>
            The order is node major, dof minor.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MGroup.Solvers.DofSet.IntersectionWith(MGroup.Solvers.DofSet)">
            <summary>
            Returns a <see cref="T:MGroup.Solvers.DofSet"/> that only contains the dofs this instance has in common with 
            <paramref name="other"/>. This intersection excludes nodes that are not common or do not have common dofs in both 
            this instance and <paramref name="other"/>. This instance will be unusable afterwards.
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:MGroup.Solvers.Exceptions.SolverDidNotConvergeException">
            <summary>
            The exception that is thrown when an iterative solver cannot converge to the desired accuracy. This usually indicates
            that the problem is not well defined or that the solver chosen is not appropriate for that problem. However, it is also
            possible that the desired accuracy is just too strict, in which case relaxing it will allow the solver to converge to an 
            acceptable solution.
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Exceptions.SolverDidNotConvergeException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.Solvers.Exceptions.SolverDidNotConvergeException"/> class.
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Exceptions.SolverDidNotConvergeException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.Solvers.Exceptions.SolverDidNotConvergeException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:MGroup.Solvers.Exceptions.SolverDidNotConvergeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.Solvers.Exceptions.SolverDidNotConvergeException"/> class with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="inner">The exception that is the cause of the current exception. If the innerException parameter is not 
                a null reference, the current exception is raised in a catch block that handles the inner exception. </param>
        </member>
        <member name="T:MGroup.Solvers.IntDofTable">
            <summary>
            A <see cref="!:ITable&lt;int, int, int&gt;"/> that associates the freedom degrees of nodes with their ordinal number.
            Nodes and dofs are represented by their ids, which must be unique.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.IntDofTable.Find(System.Predicate{System.Int32})">
            <summary>
            Finds and returns the an entry for which the value satisfies <paramref name="predicate"/>.
            If none is found, a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> will be thrown.
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:MGroup.Solvers.IntDofTable.GetSubtableForNodes(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            
            </summary>
            <param name="nodes">If one of these is not contained in the original table, it will be ignored.</param>
        </member>
        <member name="M:MGroup.Solvers.IntDofTable.Reorder(System.Collections.Generic.IReadOnlyList{System.Int32},System.Boolean)">
            <summary>
            Renumbers the dof indices according to the given permutation vector and direction. 
            If (<paramref name="oldToNew"/> == true), then newIndex[dof] = <paramref name="permutation"/>[oldIndex[dof]].
            Else oldIndex[dof] = <paramref name="permutation"/>[nwIndex[dof]]
            </summary>
            <param name="permutation">The permutation vector.</param>
            <param name="oldToNew">The direction it should be applied to.</param>
        </member>
        <member name="M:MGroup.Solvers.IntDofTable.TryAdd(System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds the specified (<paramref name="row"/>, <paramref name="col"/>, <paramref name="value"/>) entry to the table. 
            Returns true, if the insertion was successful, or false, if the table already contained the specified entry.
            </summary>
            <param name="row">The </param>
            <param name="col"></param>
            <param name="value"></param>
        </member>
        <member name="T:MGroup.Solvers.Iterative.PcgSolver">
            <summary>
            Iterative solver for models with only 1 subdomain. Uses the Proconditioned Conjugate Gradient algorithm.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Iterative.PcgSolver.Solve">
            <summary>
            Solves the linear system with PCG method. If the matrix has been modified, a new preconditioner will be computed.
            </summary>
        </member>
        <member name="M:MGroup.Solvers.Logging.SolverLogger.LogTaskDuration(System.String,System.Int64)">
            <summary>
            Adds the duration of the selected task to the duration of the same task during the current analysis step.
            </summary>
            <param name="task"></param>
            <param name="duration"></param>
        </member>
        <member name="M:MGroup.Solvers.Logging.SolverLogger.IncrementAnalysisStep">
            <summary>
            Each iteration is defined by the solution phase of ISolver. Dof ordering and matrix assembly may also be included, 
            but they are not necessarily repeated in all analyses. Thus call it at the end of the Solve() method.
            </summary>
        </member>
        <member name="T:MGroup.Solvers.SingleSubdomainSolverBase`1">
            <summary>
            Base implementation for solver that do not use domain decomposition.
            Authors: Serafeim Bakalakos
            </summary>
            <typeparam name="TMatrix">The type of the linear system's matrix.</typeparam>
        </member>
        <member name="M:MGroup.Solvers.SingleSubdomainSolverBase`1.InverseSystemMatrixTimesOtherMatrix(System.Collections.Generic.Dictionary{System.Int32,MGroup.LinearAlgebra.Matrices.IMatrixView})">
            <summary>
            Solves multiple linear systems A * X = B, where: A is one of the matrices stored in <see cref="N:MGroup.Solvers.LinearSystem"/>,
            B is the corresponding matrix in <paramref name="otherMatrix"/> and X is the corresponding matrix that will be 
            calculated as the result of inv(A) * B. 
            </summary>
            <param name="otherMatrix">
            The right hand side matrix for each subdomain. If the linear systems are A * X = B, then B is one of the matrices in
            <paramref name="otherMatrix"/>.</param>
        </member>
    </members>
</doc>
